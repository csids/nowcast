#' Fake data for mortality registration
#'
#' The fake data for mortality registration is generated by combining the daily
#' death counts and days of registration delay.
#'
#' The expected death counts per day is 115 with standard deviation 10.
#'
#' The expected registration delay is set to be 7 days.
#'
#' @format
#' \describe{
#' \item{doe}{Date og event}
#' \item{dor}{Date of registration}
#' }
"data_fake_nowcasting_raw"


gen_fake_death_registration <- function() {
  doe <- NULL
  dor <- NULL
  . <- NULL
  location_code <- NULL


  set.seed(1)

  start_date <- as.Date("2018-01-01")
  end_date <- as.Date("2020-01-01")

  dates = seq.Date(
    from = start_date,
    to = end_date,
    by = 1
  )


  # each week in norway, ca 800 death
  # each day, ca 115 death (assume to be N(115, sigma))
  death_mu <- 115
  death_sigma <- 10
  death_each_day <- stats::rnorm(length(dates),
                                 death_mu,
                                 death_sigma)
  death_each_day <- round(death_each_day, digits = 0)


  # registration delay, on average 7 days (one week)
  # poisson(7)

  # for each date, create separate delays
  d <- vector('list', length = length(dates))
  for(i in 1:length(d)){
    d[[i]] <- doe_dor_table(doe = dates[i],
                            n_death = death_each_day[i],
                            delay_average = 7)

  }

  d <- rbindlist(d)
  d[, location_code := 'norge']



  # data_fake_nowcasting_raw <- d
  # save(data_fake_nowcasting_raw, file = "data/data_fake_nowcasting_raw.rda", compress = "bzip2")

  return(d)
}



# expand dor table for each doe
# only for internal use

doe_dor_table <- function(doe, n_death, delay_average){
  # doe <- dates[1]
  # n_death <- 115
  # delay_average <- 7
  delay_each_day <- stats::rpois(n_death,
                          lambda = delay_average)

  dor <- doe + delay_each_day
  d <- data.table(doe = doe, dor = dor)
  return(d)
}

